<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>lijinhao's blog | lijinhao's blog</title><meta name="author" content="lijinhao"><meta name="copyright" content="lijinhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="NoSQL数据库概述NoSQL(NoSQL&#x3D;Not Only SQL)，意即”不仅仅是SQL”，泛指 非关系型的数据库 ：NoSQL不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。  不遵循SQL标准 不支持ACID（但支持事务） 远超于SQL的性能  适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的  不适用场景 需要事务支持"><meta property="og:type" content="article"><meta property="og:title" content="lijinhao&#39;s blog"><meta property="og:url" content="https://lijinhao.site/2022/05/25/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/index.html"><meta property="og:site_name" content="lijinhao&#39;s blog"><meta property="og:description" content="NoSQL数据库概述NoSQL(NoSQL&#x3D;Not Only SQL)，意即”不仅仅是SQL”，泛指 非关系型的数据库 ：NoSQL不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。  不遵循SQL标准 不支持ACID（但支持事务） 远超于SQL的性能  适用场景 对数据高并发的读写 海量数据的读写 对数据高可扩展性的  不适用场景 需要事务支持"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><meta property="article:published_time" content="2022-05-25T03:08:12.392Z"><meta property="article:modified_time" content="2022-06-17T08:17:09.504Z"><meta property="article:author" content="lijinhao"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lijinhao.site/2022/05/25/NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},relativeDate:{homepage:!1,post:!1},runtime:"days",date_suffix:{just:"Just",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"lijinhao's blog",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-06-17 16:17:09"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom@1.0.0.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/portrait.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lijinhao's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-25T03:08:12.392Z" title="Created 2022-05-25 11:08:12">2022-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-17T08:17:09.504Z" title="Updated 2022-06-17 16:17:09">2022-06-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NoSQL(NoSQL=Not Only SQL)，意即”不仅仅是SQL”，泛指 <strong>非关系型的数据库</strong> ：NoSQL不依赖业务逻辑方式存储，而以简单的 <strong>key-value</strong> 模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准</li><li>不支持ACID（但支持事务）</li><li>远超于SQL的性能</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系，需要<strong>即席</strong>查询</li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>几乎覆盖了Memcached的绝大部分功能；</li><li>数据都在内存中，支持<strong>持久化</strong>，主要用作备份恢复；</li><li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如<strong>list、set、hash、zset</strong>等；</li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库。</li></ul><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><ul><li>高性能、开源、模式自由(schema free)的<strong>文档型数据库</strong>；</li><li>数据都在内存中，如果内存不足，把不常用的数据保存到硬盘；</li><li>虽然是<strong>key-value</strong>模式，但是对value(尤其是<strong>json</strong>)提供了丰富的查询功能支持二进制数据及大型对象；</li><li>可以根据数据的特点<strong>替代 RDBMS</strong>，成为独立的数据库。或者配合RDBMS，存储特定的数据。</li></ul><h1 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h1><p>默认16个数据库，类似数组下标从0开始，初始默认使用0号库</p><p>使用命令<code>select&lt;dbid&gt;</code>来切换数据库。如：select8统一密码管理，所有库同样密码。</p><ul><li>dbsize查看当前数据库的<code>key</code>的数量</li><li>flushdb清空当前库</li><li>flusha通杀全部库</li></ul><p>Redis是<strong>单线程+多路IO复用技术</strong>，<strong>多路复用</strong>是指使用一个线程来检查多个<strong>文件描述符（Socket）</strong>的就绪状态，比如调用<strong>select</strong>和<strong>poll</strong>函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池)。</p><p><strong>串行 VS 多线程 + 锁（memcached单线程 + 多路IO复用Redis）</strong><br>Redis与Memcache三点不同：</p><ol><li>支持多数据类型；</li><li>支持持久化；</li><li>单线程+多路IO复用；</li></ol><p>![image-20220528223603211](/Users/baikal/Library/Application Support/typora-user-images/image-20220528223603211.png)</p><h3 id="key键操作"><a href="#key键操作" class="headerlink" title="key键操作"></a>key键操作</h3><ul><li><code>keys *</code>查看当前库所有key(匹配：keys *1)</li><li><code>exists key</code>判断某个key是否存在</li><li><code>type key</code>查看key是什么类型</li><li><code>del key</code> 删除指定的key数据</li><li><code>unlink key</code>根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><code>expire key 10</code> 10秒钟：为给定的key设置过期时间，</li><li><code>ttl key</code>查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>select</code>命令切换数据库</li><li><code>dbsize</code>查看当前数据库的key的数量</li></ul><ul><li><p><code>set key value</code> 设置值</p></li><li><p><code>append key value</code> 追加值</p></li><li><p><code>get value</code> 获取值</p></li><li><p><code>strlen key</code> 获取值长度</p></li><li><p><code>setnx &lt;key&gt;&lt;value &gt;</code>只有在key不存在时设置key的值</p></li><li><p><code>incr &lt;key&gt;</code> 将key中储存的数字值增1</p></li><li><p><code>decr &lt;key&gt;</code> 将key中储存的数字值减1</p></li><li><p><code>incrby &lt;key&gt; step</code> 将key中储存的数字值增加step</p></li></ul><h4 id="incr-操作"><a href="#incr-操作" class="headerlink" title="incr 操作"></a>incr 操作</h4><ul><li><p>具有原子性</p><ol><li>所谓<strong>原子操作是指不会被线程调度机制打断的操作</strong>；这种操作一旦开始，就一直运行到结束，中间不会有任何<strong>context switch(切换到另个线程)</strong></li><li>在单线程中，能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li><li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li></ol><p>Redis单命令的原子性主要得益于Redis的单线程。</p><p>案例</p><p>![image-20220529004352611](/Users/baikal/Library/Application Support/typora-user-images/image-20220529004352611.png)</p></li></ul><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>String是Redis最基本的类型，可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value</strong>。</li><li>String类型是<strong>二进制安全</strong>（只要数据能用二进制表示，就能存入数据库）的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是<strong>512M</strong>。</li></ul><p><code>mset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;.....</code><br>同时设置一个或多个<code>key-value</code>对<code>mget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;.....</code><br>同时获取一个或多个value</p><p><code>msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;....</code><br>同时设置一个或多个<code>key-value</code>对，当且仅当所有给定key都不存在</p><p><strong>原子性，有一个失败则都失败</strong></p><p><code>getrange &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;</code>获得值的范围，类似java中的<code>str.substring(左开，右闭)</code></p><p><code>setrange &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;</code></p><p>用<code>&lt;value&gt;</code>覆写<code>&lt;key&gt;</code>所储存的字符串值，从&lt;起始位置&gt;开始（索引从0开始）</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; set name lucymary</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; getrange name 0 3</span><br><span class="line">&quot;lucy&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; setrange name 3 abc</span><br><span class="line">(integer) 8</span><br><span class="line">127.0.0.1:6379[1]&gt; get name</span><br><span class="line">&quot;lucabcry&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure><p><code>setex &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;</code><br>设置键值的同时，设置过期时间，单位秒</p><p><code>getset &lt;key&gt;&lt;value&gt;</code><br>以新换旧，设置了新值同时获得旧值</p><h3 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h3><p>String的数据结构为简单动态字符串(Simple Dynamic String，缩写SDS)<strong>是可以修改的字符串</strong>，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。</p><p>![image-20220530200505815](/Users/baikal/Library/Application Support/typora-user-images/image-20220530200505815.png)</p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len，当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h2 id="Redis-List"><a href="#Redis-List" class="headerlink" title="Redis List"></a>Redis List</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ol><li><p>单键多值</p><p>Redis List是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>它的底层实际是个<strong>双向链表</strong>，两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p>![image-20220530202203342](/Users/baikal/Library/Application Support/typora-user-images/image-20220530202203342.png)</p></li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p><code>lpush/rpush &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt;...</code>从左边/右边插入一个或多个值。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; lpush k1 v1 k2 v2 k3 v3</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379[1]&gt; lrange k1 0 -1</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;k3&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">4) &quot;k2&quot;</span><br><span class="line">5) &quot;v1&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>lpop/rpop &lt;key&gt;</code> 从左边/右边吐出一个值。<strong>值在键在，值光键亡</strong></p></li><li><p><code>rpoplpush &lt;key1&gt; &lt;key2&gt;</code> 从<code>&lt;key1&gt;</code>列表右边吐出一个值，插到<code>&lt;key2&gt;</code>列表左边。</p></li><li><p><code>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;</code>按照索引下标获得元素（从左到右)</p></li><li><p><code>lrange mylist 0 -1</code></p><p>0：左边第一个，-1：右边第一个，（0-1表示获取所有)</p></li><li><p><code>lindex &lt;key&gt; &lt;index&gt;</code>按照索引下标获得元素（从左到右）</p></li><li><p><code>llen&lt;key&gt;</code>获得列表长度</p></li><li><p><code>linsert &lt;key&gt; 【before｜after】 &lt;value&gt; &lt;newvalue&gt;</code>在<code>&lt;value&gt;</code>的【后面｜前面】插入<code>&lt;newvalue&gt;</code>插入值</p></li><li><p><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code>从左边删除n个<code>value</code>(从左到右）</p></li><li><p><code>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code>将列表key下标为index的值替换成value</p></li></ol><h3 id="List-数据结构"><a href="#List-数据结构" class="headerlink" title="List 数据结构"></a>List 数据结构</h3><p>List的数据结构为快速链表<code>quickList</code></p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是<code>ziplist</code>，也即是压缩列表</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候，多个<code>ziplist</code>作为节点node， 被连接🔗成为quicklist。</p><p>![image-20220530205306043](/Users/baikal/Library/Application Support/typora-user-images/image-20220530205306043.png)</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针<code>prev</code>和<code>next</code>。</p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个st集合内的重要接口，这个也是list所不能提供的</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的Hash表，所以添加，删除，查找的**复杂度都是0(1)**。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p><code>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt;...</code><br>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</p></li><li><p><code>smembers &lt;key&gt;</code>取出该集合的所有值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; sadd k1 v1 v2 v3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379[1]&gt; SMEMBERS k1</span><br><span class="line">1) &quot;v3&quot;</span><br><span class="line">2) &quot;v1&quot;</span><br><span class="line">3) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>sismember &lt;key&gt; &lt;value&gt;</code>判断集合<code>&lt;key&gt;</code>是否为含有该<code>&lt;value&gt;</code>值，有则为1，没有则为0</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; SISMEMBER k1 v1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p><code>scard &lt;key&gt;</code>返回该集合的元素个数</p></li><li><p><code>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ...</code>删除集合中的某个元素</p></li><li><p><code>spop &lt;key&gt;</code> <strong>随机从该集合中吐出一个值</strong></p></li><li><p><code>srandmember &lt;key&gt; &lt;n&gt;</code>随机从该集合中取出n个值，不会从集合中删除</p></li><li><p><code>smove &lt;source&gt; &lt;destination&gt; value</code> 把集合中一个值从一个集合移动到另一个集合</p></li><li><p><code>sinter &lt;key1&gt; &lt;key2&gt;</code>返回两个集合的<strong>交集</strong>元素</p></li><li><p><code>sunion&lt;key1&gt; &lt;key2&gt;</code>返回两个集合的<strong>并集</strong>元素</p></li><li><p><code>sdif &lt;key1&gt; &lt;key2&gt;</code> 返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</p></li></ol><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><p>跟Java的HashSet类似，Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。<br>Redis的Set结构也是一样，它的内部也使用Hash结构，所有的value都指向同一个内部值。</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis Hash是一个键值对集合</p><p>Redis Hash是一个String类型的<strong>field</strong>和<strong>value</strong>的映射表，Hash特别适合用于存储对象</p><p>类似Java里面的<code>Map&lt;String, Object&gt;</code></p><p>![image-20220531140159033](/Users/baikal/Library/Application Support/typora-user-images/image-20220531140159033.png)</p><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p><p>主要有以下2种存储方式：</p><p>![image-20220531141342119](/Users/baikal/Library/Application Support/typora-user-images/image-20220531141342119.png)</p><p>Hash法通过**key(用户ID)+field(属性标签)**就可以操作对应属性数据，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code>给 <code>&lt;key&gt;</code>集合中的<code>&lt;field&gt;</code>键赋值<code>&lt;value&gt;</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hset user:1001 id 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hset user:1001 name zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user:1001 id</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user:1001 name</span><br><span class="line">&quot;zhangsan&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>hget &lt;keyl&gt; &lt;field&gt;</code>从<code>&lt;keyl&gt;</code>集合<code>&lt;field&gt;</code>取出<code>value</code></p></li><li><p><code>hmset &lt;keyl&gt; &lt;fieldl&gt; &lt;value&gt; &lt;field2&gt; &lt;value2&gt; ...</code>批量设置hash的值</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; hmset user:1002 id 2 name lisi age 30</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; hget user:1002 id</span><br><span class="line">&quot;2&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>hexists&lt;keyl&gt; &lt;field&gt;</code> 查看哈希表key中，给定域field是否存在</p></li><li><p><code>hkeys &lt;key&gt;</code>列出该hash集合的所有field</p></li><li><p><code>hvals&lt;key&gt;</code>列出该hash集合的所有value</p></li><li><p><code>hinerby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code> 为哈希表<code>key</code>中的域<code>field</code>的值加上增量1 -1</p></li><li><p><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code>将哈希表<code>key</code>中的域<code>field</code>的值设置为<code>value</code>，当且仅当域<code>field</code>不存在</p></li></ol><h3 id="Hash数据结构"><a href="#Hash数据结构" class="headerlink" title="Hash数据结构"></a>Hash数据结构</h3><p>Hash类型对应的数据结构是两种：ziplist(压缩列表)，hashtable(哈希表)。</p><p>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</p><h2 id="有序集合Zset（sorted-set）"><a href="#有序集合Zset（sorted-set）" class="headerlink" title="有序集合Zset（sorted set）"></a>有序集合Zset（sorted set）</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。<strong>不同之处</strong>是有序集合的每个成员都关联了一个**评分(score)**，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</p><p><strong>集合的成员是唯一的，但是评分可以是重复的</strong>。</p><p>因为元素是有序的，所以你也可以很快的根据评分(score)或者次序(position)来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h3 id="Zset数据结构"><a href="#Zset数据结构" class="headerlink" title="Zset数据结构"></a>Zset数据结构</h3><p>**SortedSet(zset)**是Redis提供的一个非常特别的数据结构</p><p>一方面它等价于Java的数据结构<code>Map&lt;String, Double&gt;</code>，可以给每一个元素value赋予一个权重score</p><p>另一方面它又类似于<code>TreeSet</code>，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li><p><strong>ZADD key score member [[score member] [score member] …]</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; zadd page_rank 10 google.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; zadd page_rank 9 baidu.com 8 bing.com</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379[1]&gt; zrange page_rank 0 -1 withscores</span><br><span class="line">1) &quot;bing.com&quot;</span><br><span class="line">2) &quot;8&quot;</span><br><span class="line">3) &quot;baidu.com&quot;</span><br><span class="line">4) &quot;9&quot;</span><br><span class="line">5) &quot;google.com&quot;</span><br><span class="line">6) &quot;10&quot;</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>ZCARD key</strong> 返回有序集 <code>key</code> 的基数，当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; zadd salary 2000 tom</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; zcard salary</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; zadd salary 5000 jack</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; zcard salary</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p><strong>ZCOUNT key min max</strong></p><p>返回有序集 <code>key</code> 中， <code>score</code> 值在 <code>min</code> 和 <code>max</code> 之间(默认包括 <code>score</code> 值等于 <code>min</code> 或 <code>max</code> )的成员的数量。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; zcount salary 2000 5000</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure></li><li><p><strong>ZINCRBY key increment member</strong></p></li></ol><p>​ 为有序集 <code>key</code> 的成员 <code>member</code> 的 <code>score</code> 值加上增量 <code>increment</code></p><p>​ 可以通过传递一个负数值 <code>increment</code> ，让 <code>score</code> 减去相应的值，比如 <code>ZINCRBY key -5 member</code> ，就是让 <code>member</code> 的 <code>score</code> 值减去 <code>5</code></p><p>​ 当 <code>key</code> 不存在，或 <code>member</code> 不是 <code>key</code> 的成员时， <code>ZINCRBY key increment member</code> 等同于 <code>ZADD key increment member</code></p><p>​ 当 <code>key</code> 不是有序集类型时，返回一个错误</p><ol start="5"><li><p><strong>ZRANGE key start stop [WITHSCORES]</strong></p><p>返回有序集 <code>key</code> 中，指定区间内的成员。</p><p>其中成员的位置按 <code>score</code> 值递增(从小到大)来排序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; zrange salary 0 -1 withscores   # 显示整个有序集成员</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;2000&quot;</span><br><span class="line">3) &quot;jack&quot;</span><br><span class="line">4) &quot;5000&quot;</span><br></pre></td></tr></table></figure></li></ol><p>zset底层使用了两个数据结构：</p><ol><li>Hash：作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><p>​ 有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Rdis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><ul><li><p>有序链表</p><p>![image-20220531201752494](/Users/baikal/Library/Application Support/typora-user-images/image-20220531201752494.png)</p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p></li><li><p>跳跃表</p><p>![image-20220531201828720](/Users/baikal/Library/Application Support/typora-user-images/image-20220531201828720.png)</p><p>从第2层开始，1节点比51节点小，向后比较。21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层<br>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下<br>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p></li></ul><p>案例：利用zset实现文章访问量排行榜</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; zadd topn 1000 java 500 C++ 1200 Python 400 Golang</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379[1]&gt; ZREVRANGE topn 0 9 withscores</span><br><span class="line">1) &quot;Python&quot;</span><br><span class="line">2) &quot;1200&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;1000&quot;</span><br><span class="line">5) &quot;C++&quot;</span><br><span class="line">6) &quot;500&quot;</span><br><span class="line">7) &quot;Golang&quot;</span><br><span class="line">8) &quot;400&quot;</span><br></pre></td></tr></table></figure><h2 id="BitMaps"><a href="#BitMaps" class="headerlink" title="BitMaps"></a>BitMaps</h2><p>现代计算机用二进制（位）作为信息的基础单位，1个字节等于8位，例如”abc”字符串是由3个字节组成，但实际在计算机存储都时将其用二进制表示，“abc”分别对应的ASCII码分别是97、98、99，对应的二进制分别是01100001、01100010和01100011，如下图所示。</p><p>![image-20220531220847669](/Users/baikal/Library/Application Support/typora-user-images/image-20220531220847669.png)</p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。Redis提供了Bitmaps这个”数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型，实际上它就是字符串(key-value)，但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</li></ol><p>![image-20220531221011076](/Users/baikal/Library/Application Support/typora-user-images/image-20220531221011076.png)</p><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ol><li><p><strong>SETBIT key offset value</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; setbit users:20210101 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; setbit users:20210101 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; setbit users:20210101 11 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; setbit users:20210101 15 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt; setbit users:20210101 19 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​ 完成上述指令后，Bitmaps初始化的结果如下图所示。</p><p>![image-20220531221733102](/Users/baikal/Library/Application Support/typora-user-images/image-20220531221733102.png)</p><p>​ 可用于表示20个用户是否对网站进行了访问。</p><p>​ 很多应用的用户id以一个指定数字（例如10000）开头，直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做setbit操作时将用户id减去这个指定数字 。</p><p>​ 在第一次初始化Bitmaps时，假如偏移量非常 大，那么整个初始化过程执行会 比较慢，可能会造成Redis的阻塞。</p><p>​ setrange警告⚠️</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当生成一个很长的字符串时，Redis 需要分配内存空间，该操作有时候可能会造成服务器阻塞(block)。在2010年的Macbook Pro上，设置偏移量为 536870911(512MB 内存分配)，耗费约 300 毫秒， 设置偏移量为 134217728(128MB 内存分配)，耗费约 80 毫秒，设置偏移量 33554432(32MB 内存分配)，耗费约 30 毫秒，设置偏移量为 8388608(8MB 内存分配)，耗费约 8 毫秒。 注意若首次内存分配成功之后，再对同一个 key 调用 SETRANGE 操作，无须再重新内存。</span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>GETBIT key offset</strong></p><p>对 <code>key</code> 所储存的字符串值，获取指定偏移量上的位(bit)。</p><p>当 <code>offset</code> 比字符串值的长度大，或者 <code>key</code> 不存在时，返回 <code>0</code> 。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; GETBIT users:20210101 15</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379[1]&gt; GETBIT users:20210101 18</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>BITCOUNT key [start] [end]</strong></p><p>计算给定字符串中，被设置为 <code>1</code> 的比特位的数量</p><p>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 <code>start</code> 或 <code>end</code> 参数，可以让计数只在特定的位上进行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; BITCOUNT users:20210101</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379[1]&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>BITOP operation destkey key [key …]</strong></p><p>对一个或多个保存二进制位的字符串 <code>key</code> 进行位元操作，并将结果保存到 <code>destkey</code> 上。</p><p><code>operation</code> 可以是 <code>AND</code> 、 <code>OR</code> 、 <code>NOT</code> 、 <code>XOR</code> 这四种操作中的任意一种：</p><ul><li><p><code>BITOP AND destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑并，并将结果保存到 <code>destkey</code> 。</p></li><li><p><code>BITOP OR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑或，并将结果保存到 <code>destkey</code> 。</p></li><li><p><code>BITOP XOR destkey key [key ...]</code> ，对一个或多个 <code>key</code> 求逻辑异或，并将结果保存到 <code>destkey</code> 。</p></li><li><p><code>BITOP NOT destkey key</code> ，对给定 <code>key</code> 求逻辑非，并将结果保存到 <code>destkey</code> 。</p></li></ul><p>除了 <code>NOT</code> 操作之外，其他操作都可以接受一个或多个 <code>key</code> 作为输入。</p></li></ol><p>计算任意一天都访问过网站的用户数量（如月活跃），可以使用or求并集</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; BITOP or unique:users:or:20210101 unique:users:20210103 unique:users:20210104</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[1]&gt; BITOP and unique:users:and:20210101 unique:users:20210103 unique:users:20210104</span><br></pre></td></tr></table></figure><p>![image-20220531224435126](/Users/baikal/Library/Application Support/typora-user-images/image-20220531224435126.png)</p><p>![image-20220531224608493](/Users/baikal/Library/Application Support/typora-user-images/image-20220531224608493.png)</p><p>​ 很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的。</p><p>![image-20220531224649404](/Users/baikal/Library/Application Support/typora-user-images/image-20220531224649404.png)</p><p>​ 但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>​ 在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量），可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。</p><p>解决基数问题有很多种方案：</p><ol><li><p>数据存储在MySQL表中，使用distinct count计算不重复个数。</p></li><li><p>使用Redis提供的hash、set、bitmaps等数据结构来处理。</p></li></ol><p>​ 以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？Redis推出了<code>HyperLogLog</code>。</p><p>​ Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>​ 在 Redis 里面，每个 HyperLogLog 键只需要花费 <code>12 KB</code> 内存，就可以计算接近 <code>2^64</code>个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>​ 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么是基数?</span><br><span class="line"></span><br><span class="line">比如数据集 &#123;1, 3, 5, 7, 5, 7, 8&#125;，那么这个数据集的基数集为 &#123;1, 3, 5 ,7, 8&#125;，基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</span><br></pre></td></tr></table></figure><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><p>​ Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h1 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h2><p>Redis发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis客户端可以订阅任意数量的频道。</p><p><strong>SUBSCRIBE</strong>、<strong>UNSUBSCRIBE</strong> 和 <strong>PUBLISH</strong>三个命令实现了发布与订阅信息泛型（Publish/Subscribe messaging paradigm）</p><p>在这个实现中，发送者（发送信息的客户端）不是将信息直接发送给特定的接收者（接收信息的客户端）， 而是将信息发送给频道（channel）， 然后由频道将信息转发给所有对这个频道感兴趣的订阅者</p><p>发送者无须知道任何关于订阅者的信息， 而订阅者也无须知道是那个客户端给它发送信息， 它只要关注自己感兴趣的频道即可</p><p>对发布者和订阅者进行解构（decoupling）， 可以极大地提高系统的扩展性（scalability）， 并得到一个更动态的网络拓扑（network topology）</p><p>比如说， 要订阅频道 <code>foo</code> 和 <code>bar</code> ， 客户端可以使用频道名字作为参数来调用 <a target="_blank" rel="noopener" href="http://doc.redisfans.com/pub_sub/subscribe.html#subscribe"><em>SUBSCRIBE</em></a> 命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE foo bar</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;foo&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;bar&quot;</span><br><span class="line">3) (integer) 2</span><br></pre></td></tr></table></figure><p>![image-20220531213405135](/Users/baikal/Library/Application Support/typora-user-images/image-20220531213405135.png)</p><h2 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h2><p>Redis 的发布与订阅实现支持模式匹配（pattern matching）： 客户端可以订阅一个带 <code>*</code> 号的模式， 如果某个/某些频道的名字和这个模式匹配， 那么当有信息发送给这个/这些频道的时候， 客户端也会收到这个/这些频道的信息。</p><p>执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PSUBSCRIBE news.*</span></span><br></pre></td></tr></table></figure><p>的客户端将收到来自 <code>news.art.figurative</code> 、 <code>news.music.jazz</code> 等频道的信息。</p><p>客户端订阅的模式里面可以包含多个 glob 风格的通配符， 比如 <code>*</code> 、 <code>?</code> 和 <code>[...]</code> ， 等等。</p><p>执行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> PUNSUBSCRIBE news.*</span></span><br></pre></td></tr></table></figure><p>将退订 <code>news.*</code> 模式， 其他已订阅的模式不会被影响</p><h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><img src="/Users/baikal/Library/Application Support/typora-user-images/image-20220606231208493.png" alt="image-20220606231208493" style="zoom:50%"><p>从输入Mut命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。 组队的过程中可以通过discard来放弃组队。</p><img src="/Users/baikal/Library/Application Support/typora-user-images/image-20220606225411344.png" alt="image-20220606225411344" style="zoom:33%"><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>![image-20220606225648298](/Users/baikal/Library/Application Support/typora-user-images/image-20220606225648298.png)</p><p>悲观锁(Pessimistic Lock)，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁</strong>等，都是在做操作之前先上锁。</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>![image-20220606225711761](/Users/baikal/Library/Application Support/typora-user-images/image-20220606225711761.png)</p><p>乐观锁(Optimistic Lock)，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号</strong>等机制。乐观锁适用于<strong>多读</strong>的应用类型，这样可以<strong>提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><h2 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h2><ol><li>单独的隔离操作<br>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>没有隔离级别的概念<br>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li><li>不保证原子性<br>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ol></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/05/10/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/portrait.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">lijinhao</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">67</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">22</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leekinghou"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leekinghou" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lijinhao716@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">醉后不知天在水，满船清梦压星河✨<div class="twopeople"><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.guole.fun/js/twopeople1.js"></script><script src="https://cdn.guole.fun/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.guole.fun/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">NoSQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.</span> <span class="toc-text">不适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-number">1.4.</span> <span class="toc-text">Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MongoDB"><span class="toc-number">1.5.</span> <span class="toc-text">MongoDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-1"><span class="toc-number">2.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key%E9%94%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.1.</span> <span class="toc-text">key键操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#incr-%E6%93%8D%E4%BD%9C"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">incr 操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88String%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">Redis字符串（String）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">String数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-List"><span class="toc-number">2.2.</span> <span class="toc-text">Redis List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">List 数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">2.3.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">Set数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">2.4.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">2.4.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">Hash数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset%EF%BC%88sorted-set%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">有序集合Zset（sorted set）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.2.</span> <span class="toc-text">Zset数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">2.5.3.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BitMaps"><span class="toc-number">2.6.</span> <span class="toc-text">BitMaps</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">2.6.1.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">2.7.</span> <span class="toc-text">HyperLogLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial"><span class="toc-number">2.8.</span> <span class="toc-text">Geospatial</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85"><span class="toc-number">3.</span> <span class="toc-text">发布与订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">3.1.</span> <span class="toc-text">什么是发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">订阅模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">乐观锁和悲观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Multi%E3%80%81Exec%E3%80%81discard"><span class="toc-number">4.1.</span> <span class="toc-text">Multi、Exec、discard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">4.2.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.3.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">Redis事务三特性</span></a></li></ol></li></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lijinhao</div><div class="framework-info"><span>Framework</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">满腔期待 常怀热情 有人等你<a target="_blank" rel="noopener" href="https://inews.gtimg.com/newsapp_ls/0/14146688226/0">Baikal♥️Swan</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script src="https://cdn-1.nesxc.com/js/smooth-scrolling.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&"/"==location.pathname&&(console.log("已挂载github calendar"),e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?Leekinghou",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"Leekinghou")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style></body></html>