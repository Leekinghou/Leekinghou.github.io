<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>K近邻 K-nearest neighbor | lijinhao's blog</title><meta name="keywords" content="ML"><meta name="author" content="lijinhao"><meta name="copyright" content="lijinhao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="K近邻 K-nearest neighbor算法 —— 物以类聚，人以群分"><meta property="og:type" content="article"><meta property="og:title" content="K近邻 K-nearest neighbor"><meta property="og:url" content="https://lijinhao.site/2021/09/26/K%E8%BF%91%E9%82%BB%20K-nearest%20neighbor/index.html"><meta property="og:site_name" content="lijinhao&#39;s blog"><meta property="og:description" content="K近邻 K-nearest neighbor算法 —— 物以类聚，人以群分"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://files.catbox.moe/yechci.png"><meta property="article:published_time" content="2021-09-26T06:59:17.228Z"><meta property="article:modified_time" content="2021-10-05T04:07:21.380Z"><meta property="article:author" content="lijinhao"><meta property="article:tag" content="Machine Learning"><meta property="article:tag" content="K近邻 K-nearest neighbor"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://files.catbox.moe/yechci.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lijinhao.site/2021/09/26/K%E8%BF%91%E9%82%BB%20K-nearest%20neighbor/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"},relativeDate:{homepage:!1,post:!1},runtime:"days",date_suffix:{just:"Just",min:"minutes ago",hour:"hours ago",day:"days ago",month:"months ago"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"K近邻 K-nearest neighbor",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-10-05 12:07:21"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside")),GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/custom@1.0.0.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/portrait.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">20</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">lijinhao's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i> <span>照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i> <span>电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">K近邻 K-nearest neighbor</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-09-26T06:59:17.228Z" title="Created 2021-09-26 14:59:17">2021-09-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-10-05T04:07:21.380Z" title="Updated 2021-10-05 12:07:21">2021-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Machine-Learning/">Machine Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="K近邻 K-nearest neighbor"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>K近邻 K-nearest neighbor算法</p><p>​ —— 物以类聚，人以群分</p><span id="more"></span><h2 id="三个基本要素"><a href="#三个基本要素" class="headerlink" title="三个基本要素"></a>三个基本要素</h2><ol><li><p>距离度量</p></li><li><p>k值选择</p></li><li><p>分类决策规则</p><img src="https://files.catbox.moe/pm8pjl.png" style="zoom:33%"></li></ol><img src="https://files.catbox.moe/th7k96.png" style="zoom:50%"><h2 id="何为物以类聚？"><a href="#何为物以类聚？" class="headerlink" title="何为物以类聚？"></a>何为物以类聚？</h2><p><strong>question: 如何区分红豆、绿豆？</strong></p><ol><li><p>同一标签的样本通常有很多相似的特征，所以同一类别的可能有扎堆现象，也就是物以类聚。</p></li><li><p>每进来一个样本，我们查看它周围的样本是什么类别的，那它也有极大可能属于该类别。</p></li><li><p>距离度量</p></li></ol><img src="https://files.catbox.moe/z81923.png" style="zoom:50%" align="left"><h2 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h2><p><img src="https://files.catbox.moe/f3ocl6.png"></p><h3 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h3><ul><li>一条直线</li></ul><h2 id="曼哈顿距离（城市街区距离）"><a href="#曼哈顿距离（城市街区距离）" class="headerlink" title="曼哈顿距离（城市街区距离）"></a>曼哈顿距离（城市街区距离）</h2><ul><li>直角边</li></ul><img src="https://files.catbox.moe/z9hdyj.png" style="zoom:50%" align="left"><h2 id="切比雪夫距离（棋盘距离）"><a href="#切比雪夫距离（棋盘距离）" class="headerlink" title="切比雪夫距离（棋盘距离）"></a>切比雪夫距离（棋盘距离）</h2><img src="https://files.catbox.moe/35ze12.png" style="zoom:50%" align="left"><h2 id="K值的选择"><a href="#K值的选择" class="headerlink" title="K值的选择"></a>K值的选择</h2><ul><li><p>选择较小的k值</p><p>用较小的邻域进行预测。预测结果对邻近的实例点非常敏感。如果邻近的实例点恰好是噪声，预测就会出错。</p></li><li><p>选择较大的k值<br>用较大的邻域进行预测。对于输入实例较远的(已经不太相似)的样本点也会对预测起作用，使预测发生错误。</p></li><li><p>在应用中先取一个较小的K值，再通过交叉验证法来选取最有的K值。</p></li></ul><h2 id="多数表决规则"><a href="#多数表决规则" class="headerlink" title="多数表决规则"></a>多数表决规则</h2><p><img src="https://files.catbox.moe/jx043q.png"></p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p><img src="https://files.catbox.moe/5pfett.png"></p><p><img src="https://files.catbox.moe/0mrowc.png"></p><p><strong>question:如何对训练数据进行 快速k近邻 搜索？</strong></p><h2 id="k近邻实现：kd树"><a href="#k近邻实现：kd树" class="headerlink" title="k近邻实现：kd树"></a>k近邻实现：kd树</h2><ul><li>最简单：线性扫描，计算实例和每一个训练实例的距离，训练集很大时，计算非常耗时</li><li>kd树：用二叉树结构存储训练数据</li></ul><h3 id="什么是kd树"><a href="#什么是kd树" class="headerlink" title="什么是kd树"></a>什么是kd树</h3><ul><li>kd树是一种对k维空间中的实例店进行存储，用以搜索用的树形数据结构。</li><li>本质是二叉树，表示对k维空间的划分</li><li>kd树的每一个节点对应于一个k维超矩形区域</li></ul><p><img src="https://files.catbox.moe/tnd0r4.png" alt="image-20210925130147333"></p><h3 id="构造kd树"><a href="#构造kd树" class="headerlink" title="构造kd树"></a>构造kd树</h3><ul><li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wM80MUbPvCAiHHm8SCxZFA">kd树算法原理讲解</a></li><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ssyfj/p/13053055.html">kd树例题（赞👍）</a></li></ul><p>question:构造完kd树后们如何进行最近邻搜索？</p><p><img src="http://dl2.iteye.com/upload/attachment/0042/4128/3f19162d-13ab-326b-9315-85e111de37ed.gif"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-l</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> norm</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        结点对象</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item = <span class="literal">None</span>, label = <span class="literal">None</span>, dim = <span class="literal">None</span>, parent = <span class="literal">None</span>, left_child = <span class="literal">None</span>, right_child = <span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            item: 结点的值(样本信息)</span></span><br><span class="line"><span class="string">            label: 结点的标签</span></span><br><span class="line"><span class="string">            dim: 结点的切分的维度(特征)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.item = item</span><br><span class="line">        self.label = label</span><br><span class="line">        self.dim = dim</span><br><span class="line">        self.parent = parent</span><br><span class="line">        self.left_child = left_child</span><br><span class="line">        self.right_child = right_child     </span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KDTree</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, aList, labelList</span>):</span></span><br><span class="line">        self.__length = <span class="number">0</span> </span><br><span class="line">        self.__root = self.__create(aList,labelList)  <span class="comment"># 根结点, 私有属性, 不可修改</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__create</span>(<span class="params">self, aList, labelList, parentNode = <span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            创建kd树</span></span><br><span class="line"><span class="string">            aList: 需要传入一个类数组对象(行数表示样本数，列数表示特征数)</span></span><br><span class="line"><span class="string">            labellist: 样本的标签</span></span><br><span class="line"><span class="string">            parentNode: 父结点</span></span><br><span class="line"><span class="string">            return: 根结点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        dataArray = np.array(aList)</span><br><span class="line">        m, n = dataArray.shape</span><br><span class="line">        labelArray = np.array(labelList).reshape(m, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 求所有特征的方差，选择最大的那个特征作为切分超平面</span></span><br><span class="line">        <span class="comment"># 获取每一个特征的方差</span></span><br><span class="line">        var_list = [np.var(dataArray[:, col]) <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取最大方差特征的索引</span></span><br><span class="line">        <span class="keyword">if</span> var_list:</span><br><span class="line">            max_index = var_list.index(<span class="built_in">max</span>(var_list))</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 样本按最大方差特征进行升序排序后，取出位于中间的样本</span></span><br><span class="line">            max_feat_ind_list = dataArray[:, max_index].argsort()</span><br><span class="line">            mid_item_index = max_feat_ind_list[m // <span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 样本为1时，返回自身</span></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">                self.__length += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> Node(</span><br><span class="line">                    dim = max_index, </span><br><span class="line">                    label = labelArray[mid_item_index], </span><br><span class="line">                    item = dataArray[mid_item_index], </span><br><span class="line">                    parent = parentNode,</span><br><span class="line">                    left_child = <span class="literal">None</span>,</span><br><span class="line">                    right_child = <span class="literal">None</span></span><br><span class="line">                )</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 生成结点</span></span><br><span class="line">            node = Node(</span><br><span class="line">                    dim = max_index, </span><br><span class="line">                    label = labelArray[mid_item_index], </span><br><span class="line">                    item = dataArray[mid_item_index], </span><br><span class="line">                    parent = parentNode,</span><br><span class="line">                    left_child = <span class="literal">None</span>,</span><br><span class="line">                    right_child = <span class="literal">None</span></span><br><span class="line">                )</span><br><span class="line">            <span class="comment"># 构建有序的子树</span></span><br><span class="line">            left_tree = dataArray[max_feat_ind_list[:m // <span class="number">2</span>:]] <span class="comment"># 左子树</span></span><br><span class="line">            left_label = labelArray[max_feat_ind_list[:m // <span class="number">2</span>]] <span class="comment"># 左子树标签</span></span><br><span class="line">            left_child = self.__create(left_tree, left_label, node)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 只有左子树，无右子树</span></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">2</span>:</span><br><span class="line">                right_child = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 右子树</span></span><br><span class="line">                right_tree = dataArray[max_feat_ind_list[m // <span class="number">2</span> + <span class="number">1</span>:]]</span><br><span class="line">                <span class="comment"># 右子树标签</span></span><br><span class="line">                right_label = labelArray[max_feat_ind_list[m // <span class="number">2</span> + <span class="number">1</span>:]]</span><br><span class="line">                right_child = self.__create(right_tree, right_label, node)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 左右子树递归调用自己，返回子树根结点</span></span><br><span class="line">        node.left_child=left_child</span><br><span class="line">        node.right_child=right_child</span><br><span class="line">        self.__length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> node </span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">root</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__root</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transfer_dict</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        查看kd树结构</span></span><br><span class="line"><span class="string">        node:需要传入根结点对象</span></span><br><span class="line"><span class="string">        return: 字典嵌套格式的kd树,字典的key是self.item,其余项作为key的值，类似下面格式</span></span><br><span class="line"><span class="string">        &#123;(1,2,3):&#123;</span></span><br><span class="line"><span class="string">                &#x27;label&#x27;:1,</span></span><br><span class="line"><span class="string">                &#x27;dim&#x27;:0,</span></span><br><span class="line"><span class="string">                &#x27;left_child&#x27;:&#123;(2,3,4):&#123;</span></span><br><span class="line"><span class="string">                                     &#x27;label&#x27;:1,</span></span><br><span class="line"><span class="string">                                     &#x27;dim&#x27;:1,</span></span><br><span class="line"><span class="string">                                     &#x27;left_child&#x27;:None,</span></span><br><span class="line"><span class="string">                                     &#x27;right_child&#x27;:None</span></span><br><span class="line"><span class="string">                                    &#125;,</span></span><br><span class="line"><span class="string">                &#x27;right_child&#x27;:&#123;(4,5,6):&#123;</span></span><br><span class="line"><span class="string">                                        &#x27;label&#x27;:1,</span></span><br><span class="line"><span class="string">                                        &#x27;dim&#x27;:1,</span></span><br><span class="line"><span class="string">                                        &#x27;left_child&#x27;:None,</span></span><br><span class="line"><span class="string">                                        &#x27;right_child&#x27;:None</span></span><br><span class="line"><span class="string">                                        &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        kd_dict = &#123;&#125;</span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)] = &#123;&#125;  <span class="comment"># 将自身值作为key</span></span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)][<span class="string">&#x27;label&#x27;</span>] = node.label[<span class="number">0</span>]</span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)][<span class="string">&#x27;dim&#x27;</span>] = node.dim</span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)][<span class="string">&#x27;parent&#x27;</span>] = <span class="built_in">tuple</span>(node.parent.item) <span class="keyword">if</span> node.parent <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)][<span class="string">&#x27;left_child&#x27;</span>] = self.transfer_dict(node.left_child)</span><br><span class="line">        kd_dict[<span class="built_in">tuple</span>(node.item)][<span class="string">&#x27;right_child&#x27;</span>] = self.transfer_dict(node.right_child)</span><br><span class="line">        <span class="keyword">return</span> kd_dict</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transfer_list</span>(<span class="params">self,node, kdList=[]</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        将kd树转化为列表嵌套字典的嵌套字典的列表输出</span></span><br><span class="line"><span class="string">        :param node: 需要传入根结点</span></span><br><span class="line"><span class="string">        :return: 返回嵌套字典的列表</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        element_dict = &#123;&#125;</span><br><span class="line">        element_dict[<span class="string">&#x27;item&#x27;</span>] = <span class="built_in">tuple</span>(node.item)</span><br><span class="line">        element_dict[<span class="string">&#x27;label&#x27;</span>] = node.label[<span class="number">0</span>]</span><br><span class="line">        element_dict[<span class="string">&#x27;dim&#x27;</span>] = node.dim</span><br><span class="line">        element_dict[<span class="string">&#x27;parent&#x27;</span>] = <span class="built_in">tuple</span>(node.parent.item) <span class="keyword">if</span> node.parent <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        element_dict[<span class="string">&#x27;left_child&#x27;</span>] = <span class="built_in">tuple</span>(node.left_child.item) <span class="keyword">if</span> node.left_child <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        element_dict[<span class="string">&#x27;right_child&#x27;</span>] = <span class="built_in">tuple</span>(node.right_child.item) <span class="keyword">if</span> node.right_child <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        kdList.append(element_dict)</span><br><span class="line">        self.transfer_list(node.left_child, kdList)</span><br><span class="line">        self.transfer_list(node.right_child, kdList)</span><br><span class="line">        <span class="keyword">return</span> kdList</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_find_nearest_neighbour</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        找最近邻点</span></span><br><span class="line"><span class="string">        :param item:需要预测的新样本</span></span><br><span class="line"><span class="string">        :return: 距离最近的样本点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        itemArray = np.array(item)</span><br><span class="line">        <span class="keyword">if</span> self.length == <span class="number">0</span>:  <span class="comment"># 空kd树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 递归找离测试点最近的那个叶结点</span></span><br><span class="line">        node = self.__root</span><br><span class="line">        <span class="keyword">if</span> self.length == <span class="number">1</span>: <span class="comment"># 只有一个样本</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cur_dim = node.dim</span><br><span class="line">            <span class="keyword">if</span> item[cur_dim] == node.item[cur_dim]:</span><br><span class="line">                <span class="keyword">return</span> node</span><br><span class="line">            <span class="keyword">elif</span> item[cur_dim] &lt; node.item[cur_dim]:  <span class="comment"># 进入左子树</span></span><br><span class="line">                <span class="keyword">if</span> node.left_child == <span class="literal">None</span>:  <span class="comment"># 左子树为空，返回自身</span></span><br><span class="line">                    <span class="keyword">return</span> node</span><br><span class="line">                node = node.left_child</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right_child == <span class="literal">None</span>:  <span class="comment"># 右子树为空，返回自身</span></span><br><span class="line">                    <span class="keyword">return</span> node</span><br><span class="line">                node = node.right_child</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">knn_algo</span>(<span class="params">self, item, k = <span class="number">1</span></span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            找到距离测试样本最近的前k个样本</span></span><br><span class="line"><span class="string">            :param item: 测试样本</span></span><br><span class="line"><span class="string">            :param k: knn算法参数，定义需要参考的最近点数量，一般为1-5</span></span><br><span class="line"><span class="string">            :return: 返回前k个样本的最大分类标签</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.length &lt;= k:</span><br><span class="line">            label_dict = &#123;&#125;</span><br><span class="line">            <span class="comment"># 获取所有label的数量</span></span><br><span class="line">            <span class="keyword">for</span> element <span class="keyword">in</span> self.transfer_list(self.root):</span><br><span class="line">                <span class="keyword">if</span> element[<span class="string">&#x27;label&#x27;</span>] <span class="keyword">in</span> label_dict:</span><br><span class="line">                    label_dict[element[<span class="string">&#x27;label&#x27;</span>]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    label_dict[element[<span class="string">&#x27;label&#x27;</span>]] = <span class="number">1</span></span><br><span class="line">            sorted_label = <span class="built_in">sorted</span>(label_dict.items(), key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>],reverse=<span class="literal">True</span>)  <span class="comment"># 给标签排序</span></span><br><span class="line">            <span class="keyword">return</span> sorted_label[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        item = np.array(item)</span><br><span class="line">        node = self._find_nearest_neighbour(item)  <span class="comment"># 找到最近的那个结点</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">None</span>:  <span class="comment"># 空树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;靠近点%s最近的叶结点为:%s&#x27;</span>%(item, node.item))</span><br><span class="line">        node_list = []</span><br><span class="line">        distance = np.sqrt(<span class="built_in">sum</span>((item-node.item)**<span class="number">2</span>))  <span class="comment"># 测试点与最近点之间的距离</span></span><br><span class="line">        least_dis = distance</span><br><span class="line">        <span class="comment"># 返回上一个父结点，判断以测试点为圆心，distance为半径的圆是否与父结点分隔超平面相交，若相交，则说明父结点的另一个子树可能存在更近的点</span></span><br><span class="line">        node_list.append([distance, <span class="built_in">tuple</span>(node.item), node.label[<span class="number">0</span>]])  <span class="comment"># 需要将距离与结点一起保存起来</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 若最近的结点不是叶结点，则说明，它还有左子树</span></span><br><span class="line">        <span class="keyword">if</span> node.left_child != <span class="literal">None</span>:</span><br><span class="line">            left_child = node.left_child</span><br><span class="line">            left_dis = np.sqrt(<span class="built_in">sum</span>((item-left_child.item)**<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(node_list) <span class="keyword">or</span> least_dis &lt; least_dis:</span><br><span class="line">                node_list.append([left_dis, <span class="built_in">tuple</span>(left_child.item), left_child.label[<span class="number">0</span>]])</span><br><span class="line">                node_list.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">                least_dis = node_list[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(node_list) <span class="keyword">else</span> node_list[k-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 回到父结点</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> node == self.root:  <span class="comment"># 已经回到kd树的根结点</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            parent = node.parent</span><br><span class="line">            <span class="comment"># 计算测试点与父结点的距离，与上面距离做比较</span></span><br><span class="line">            par_dis = np.sqrt(<span class="built_in">sum</span>((item-parent.item)**<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> k &gt;<span class="built_in">len</span>(node_list) <span class="keyword">or</span> par_dis &lt; least_dis:  <span class="comment"># k大于结点数或者父结点距离小于结点列表中最大的距离</span></span><br><span class="line">                node_list.append([par_dis, <span class="built_in">tuple</span>(parent.item) , parent.label[<span class="number">0</span>]])</span><br><span class="line">                node_list.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">                least_dis = node_list[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(node_list) <span class="keyword">else</span> node_list[k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断父结点的另一个子树与结点列表中最大的距离构成的圆是否有交集</span></span><br><span class="line">            <span class="keyword">if</span> k &gt;<span class="built_in">len</span>(node_list) <span class="keyword">or</span> <span class="built_in">abs</span>(item[parent.dim] - parent.item[parent.dim]) &lt; least_dis :  <span class="comment"># 说明父结点的另一个子树与圆有交集</span></span><br><span class="line">                <span class="comment"># 说明父结点的另一子树区域与圆有交集</span></span><br><span class="line">                other_child = parent.left_child <span class="keyword">if</span> parent.left_child != node <span class="keyword">else</span> parent.right_child  <span class="comment"># 找另一个子树</span></span><br><span class="line">                <span class="comment"># 测试点在该子结点超平面的左侧</span></span><br><span class="line">                <span class="keyword">if</span> other_child != <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> item[parent.dim] - parent.item[parent.dim] &lt;= <span class="number">0</span>:</span><br><span class="line">                        self.left_search(item,other_child,node_list,k)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.right_search(item,other_child,node_list,k)  <span class="comment"># 测试点在该子结点平面的右侧</span></span><br><span class="line"></span><br><span class="line">            node = parent  <span class="comment"># 否则继续返回上一层</span></span><br><span class="line">        <span class="comment"># 接下来取出前k个元素中最大的分类标签</span></span><br><span class="line">        label_dict = &#123;&#125;</span><br><span class="line">        node_list = node_list[:k]</span><br><span class="line">        <span class="comment"># 获取所有label的数量</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> node_list:</span><br><span class="line">            <span class="keyword">if</span> element[<span class="number">2</span>] <span class="keyword">in</span> label_dict:</span><br><span class="line">                label_dict[element[<span class="number">2</span>]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                label_dict[element[<span class="number">2</span>]] = <span class="number">1</span></span><br><span class="line">        sorted_label = <span class="built_in">sorted</span>(label_dict.items(), key=<span class="keyword">lambda</span> item:item[<span class="number">1</span>], reverse=<span class="literal">True</span>)  <span class="comment"># 给标签排序</span></span><br><span class="line">        <span class="keyword">return</span> sorted_label[<span class="number">0</span>][<span class="number">0</span>],node_list</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">left_search</span>(<span class="params">self, item, node, nodeList, k</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        按左中右顺序遍历子树结点，返回结点列表</span></span><br><span class="line"><span class="string">        :param node: 子树结点</span></span><br><span class="line"><span class="string">        :param item: 传入的测试样本</span></span><br><span class="line"><span class="string">        :param nodeList: 结点列表</span></span><br><span class="line"><span class="string">        :param k: 搜索比较的结点数量</span></span><br><span class="line"><span class="string">        :return: 结点列表</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        nodeList.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">        least_dis = nodeList[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(nodeList) <span class="keyword">else</span> nodeList[k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> node.left_child == <span class="literal">None</span> <span class="keyword">and</span> node.right_child == <span class="literal">None</span>:  <span class="comment"># 叶结点</span></span><br><span class="line">            dis = np.sqrt(<span class="built_in">sum</span>((item - node.item) ** <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> dis &lt; least_dis:</span><br><span class="line">                nodeList.append([dis, <span class="built_in">tuple</span>(node.item), node.label[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.left_search(item, node.left_child, nodeList, k)</span><br><span class="line">        <span class="comment"># 每次进行比较前都更新nodelist数据</span></span><br><span class="line">        nodeList.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">        least_dis = nodeList[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(nodeList) <span class="keyword">else</span> nodeList[k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 比较根结点</span></span><br><span class="line">        dis = np.sqrt(<span class="built_in">sum</span>((item-node.item)**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> dis &lt; least_dis:</span><br><span class="line">            nodeList.append([dis, <span class="built_in">tuple</span>(node.item), node.label[<span class="number">0</span>]])</span><br><span class="line">        <span class="comment"># 右子树</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> <span class="built_in">abs</span>(item[node.dim] - node.item[node.dim]) &lt; least_dis: <span class="comment"># 需要搜索右子树</span></span><br><span class="line">            <span class="keyword">if</span> node.right_child != <span class="literal">None</span>:</span><br><span class="line">                self.left_search(item, node.right_child, nodeList, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodeList</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">right_search</span>(<span class="params">self,item, node, nodeList, k</span>):</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        按右根左顺序遍历子树结点</span></span><br><span class="line"><span class="string">        :param item: 测试的样本点</span></span><br><span class="line"><span class="string">        :param node: 子树结点</span></span><br><span class="line"><span class="string">        :param nodeList: 结点列表</span></span><br><span class="line"><span class="string">        :param k: 搜索比较的结点数量</span></span><br><span class="line"><span class="string">        :return: 结点列表</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        nodeList.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">        least_dis = nodeList[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(nodeList) <span class="keyword">else</span> nodeList[k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> node.left_child == <span class="literal">None</span> <span class="keyword">and</span> node.right_child == <span class="literal">None</span>:  <span class="comment"># 叶结点</span></span><br><span class="line">            dis = np.sqrt(<span class="built_in">sum</span>((item - node.item) ** <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> dis &lt; least_dis:</span><br><span class="line">                nodeList.append([dis, <span class="built_in">tuple</span>(node.item), node.label[<span class="number">0</span>]])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> node.right_child != <span class="literal">None</span>:</span><br><span class="line">            self.right_search(item, node.right_child, nodeList, k)</span><br><span class="line"></span><br><span class="line">        nodeList.sort()  <span class="comment"># 对结点列表按距离排序</span></span><br><span class="line">        least_dis = nodeList[-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(nodeList) <span class="keyword">else</span> nodeList[k - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 比较根结点</span></span><br><span class="line">        dis = np.sqrt(<span class="built_in">sum</span>((item - node.item) ** <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> dis &lt; least_dis:</span><br><span class="line">            nodeList.append([dis, <span class="built_in">tuple</span>(node.item), node.label[<span class="number">0</span>]])</span><br><span class="line">        <span class="comment"># 左子树</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; <span class="built_in">len</span>(nodeList) <span class="keyword">or</span> <span class="built_in">abs</span>(item[node.dim] - node.item[node.dim]) &lt; least_dis: <span class="comment"># 需要搜索左子树</span></span><br><span class="line">            self.right_search(item, node.left_child, nodeList, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodeList</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = time.time()</span><br><span class="line">    <span class="comment"># dataArray = np.array( [[19,2 ],[ 7,0],[13,5],[3,15],[3,4],[ 3, 2], [ 8,9],[ 9,3],[17,15 ], [11,11]])</span></span><br><span class="line">    dataArray = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,size=(<span class="number">10000</span>,<span class="number">2</span>))</span><br><span class="line">    <span class="comment"># print(&#x27;dataArray&#x27;,dataArray)</span></span><br><span class="line">    <span class="comment"># label = np.array([[ 0],[ 1],[0],[ 1],[ 1],[ 1],[ 0],[ 1],[ 1], [1]])</span></span><br><span class="line">    label = np.random.randint(<span class="number">0</span>,<span class="number">3</span>,size=(<span class="number">10000</span>,<span class="number">1</span>))</span><br><span class="line">    <span class="comment"># print(&#x27;data&#x27;,np.hstack((dataArray,label)))</span></span><br><span class="line">    kd_tree = KDTree(dataArray,label)</span><br><span class="line">    <span class="comment"># kd_dict = kd_tree.transfer_dict(kd_tree.root)</span></span><br><span class="line">    <span class="comment"># print(&#x27;kd_dict:&#x27;,kd_dict)</span></span><br><span class="line">    <span class="comment"># kd_list = kd_tree.transfer_list(kd_tree.root)</span></span><br><span class="line">    <span class="comment"># print(&#x27;kd_list&#x27;,kd_list)</span></span><br><span class="line">    <span class="comment"># for i in kd_list:</span></span><br><span class="line">    <span class="comment">#     print(i)</span></span><br><span class="line">    <span class="comment"># node = kd_tree.find_nearest_neighbour([12,7])</span></span><br><span class="line">    <span class="comment"># print(&#x27;%s最近的叶结点:%s&#x27;%([12,7],node.item))</span></span><br><span class="line">    t2 = time.time()</span><br><span class="line">    label, node_list = kd_tree.knn_algo([<span class="number">12</span>,<span class="number">7</span>],k=<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;点%s的最接近的前k个点为:%s&#x27;</span>%([<span class="number">12</span>,<span class="number">7</span>], node_list))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;点%s的标签:%s&#x27;</span>%([<span class="number">12</span>,<span class="number">7</span>],label))</span><br><span class="line">    t3 = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;创建树耗时：&#x27;</span>,t2-t1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;搜索前k个最近邻点耗时：&#x27;</span>,t3-t2)</span><br></pre></td></tr></table></figure><ul><li>kd树拓展</li></ul><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_july_v/article/details/8203674">kd树拓展</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>K近邻思想：物以类聚</li><li>K近邻没有显式的训练过程</li><li>距离度量：<ol><li>欧式距离：两点之间直线</li><li>哈曼顿距离：城市街区距离</li><li>切比雪夫距离：棋盘距离</li></ol></li></ol></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Machine-Learning/">Machine Learning</a><a class="post-meta__tags" href="/tags/K%E8%BF%91%E9%82%BB-K-nearest-neighbor/">K近邻 K-nearest neighbor</a></div><div class="post_share"><div class="social-share" data-image="https://files.catbox.moe/yechci.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/28/2021-09-28-sklearn%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3/"><img class="prev-cover" src="https://files.catbox.moe/nqxbpk.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">sklearn使用函数文档</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/22/CNN/"><img class="next-cover" src="https://files.catbox.moe/rpfysi.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">CNN卷积神经网络笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2021/09/28/2021-09-28-sklearn%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E6%96%87%E6%A1%A3/" title="sklearn使用函数文档"><img class="cover" src="https://files.catbox.moe/nqxbpk.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-28</div><div class="title">sklearn使用函数文档</div></div></a></div><div><a href="/2021/09/22/CNN/" title="CNN卷积神经网络笔记"><img class="cover" src="https://files.catbox.moe/rpfysi.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-22</div><div class="title">CNN卷积神经网络笔记</div></div></a></div><div><a href="/2021/08/28/C1/" title="MACHINE LEARNING"><img class="cover" src="https://files.catbox.moe/53u8pl.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">MACHINE LEARNING</div></div></a></div><div><a href="/2021/10/20/lessonOne/" title="李宏毅2021年(春)深度学习 作业一"><img class="cover" src="https://inews.gtimg.com/newsapp_ls/0/14146721068/0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-20</div><div class="title">李宏毅2021年(春)深度学习 作业一</div></div></a></div><div><a href="/2021/11/01/self-attention(%E4%B8%8A)/" title="Self-attention(上)"><img class="cover" src="https://gitee.com/leekinghou/image/raw/master/img/20211127111636.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-01</div><div class="title">Self-attention(上)</div></div></a></div><div><a href="/2021/11/06/self-attention(%E4%B8%8B)/" title="Self-attention(下)"><img class="cover" src="https://inews.gtimg.com/newsapp_ls/0/14146047881/0" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-06</div><div class="title">Self-attention(下)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/portrait.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">lijinhao</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">61</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">36</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/leekinghou"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/leekinghou" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:lijinhao716@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">醉后不知天在水，满船清梦压星河✨<div class="twopeople"><div class="twopeople"><div class="container" style="height:200px"><canvas class="illo" width="800" height="800" style="max-width:200px;max-height:200px;touch-action:none;width:640px;height:640px"></canvas></div><script src="https://cdn.guole.fun/js/twopeople1.js"></script><script src="https://cdn.guole.fun/js/zdog.dist.js"></script><script id="rendered-js" src="https://cdn.guole.fun/js/twopeople.js"></script><style>.twopeople{margin:0;align-items:center;justify-content:center;text-align:center}canvas{display:block;margin:0 auto;cursor:move}</style></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0"><span class="toc-number">1.</span> <span class="toc-text">三个基本要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%89%A9%E4%BB%A5%E7%B1%BB%E8%81%9A%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">何为物以类聚？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">距离度量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%BC%8F%E8%B7%9D%E7%A6%BB"><span class="toc-number">3.1.</span> <span class="toc-text">欧式距离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%9F%8E%E5%B8%82%E8%A1%97%E5%8C%BA%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">曼哈顿距离（城市街区距离）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB%EF%BC%88%E6%A3%8B%E7%9B%98%E8%B7%9D%E7%A6%BB%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">切比雪夫距离（棋盘距离）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K%E5%80%BC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">6.</span> <span class="toc-text">K值的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%95%B0%E8%A1%A8%E5%86%B3%E8%A7%84%E5%88%99"><span class="toc-number">7.</span> <span class="toc-text">多数表决规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k%E8%BF%91%E9%82%BB%E5%AE%9E%E7%8E%B0%EF%BC%9Akd%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">k近邻实现：kd树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFkd%E6%A0%91"><span class="toc-number">9.1.</span> <span class="toc-text">什么是kd树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0kd%E6%A0%91"><span class="toc-number">9.2.</span> <span class="toc-text">构造kd树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By lijinhao</div><div class="framework-info"><span>Framework</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">满腔期待 常怀热情 有人等你<a target="_blank" rel="noopener" href="https://inews.gtimg.com/newsapp_ls/0/14146688226/0">Baikal♥️Swan</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">簡</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="false"></script><script src="https://cdn-1.nesxc.com/js/smooth-scrolling.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&"/"==location.pathname&&(console.log("已挂载github calendar"),e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://python-github-calendar-api.vercel.app/api?Leekinghou",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"Leekinghou")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style></body></html>